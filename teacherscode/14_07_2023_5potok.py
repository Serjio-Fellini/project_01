# -*- coding: utf-8 -*-
"""14_07_2023_5potok.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WiXDmP0khR-bJ2hqLobAJhv5R5bmrQOY
"""

# Задача 1
import random

k1 = random.randint(1,6)
k2 = random.randint(1,6)
k3 = random.randint(1,6)
k4 = random.randint(1,6)

total = k1 + k2 + k3 + k4
print (k1, k2, k3, k4, "Itog", total)

import random

k = 4
y = []
total = 0

while k != 0:
  x = random.randint(1,6)
  k -= 1
  y.append(x)
  print (y)

total = sum(y)
print (total)

# Задача 2
import random

chars = '+-/*!&$#?=@<>abcdefghijklnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890'
lenght = input('Введи длину пароля:')
password = ''

try:
  lenght = int(lenght)
  for n in range(lenght):
    password += random.choice(chars)
  print(password)
except ValueError:
  print ("Вы ввели некоректную длину пароля")
finally:
  password = ''
  lenght = input('Введи длину пароля:')
  lenght = int(lenght)
  for n in range(lenght):
    password += random.choice(chars)
  print(password)

#Calc
print ('Print q to close calc')
while True:
  s = input("Знак операции (+,-,*,/,%)")
  if s == 'q':
    break
  if s in ('+','-','*','/','%'):
    if s == '%':
      print ('x - число от которого берем %')
      print ('y - % который берем')
    x = float(input('x='))
    y = float(input('y='))
    if s == '+':
      print("%.2f" % (x+y))
    elif s == '-':
      print("%.2f" % (x-y))
    elif s == '*':
      print("%.2f" % (x*y))
    elif s == '%':
      print("%.2f" % (x / 100 * y))
    elif s == '/':
      if y != 0:
        print("%.2f" % (x / y))
      else:
        print ('Делить на 0 нельзя')
  else:
    print ('Введен не корректный символ операции')

# Сортировка пузрьком через for (bubble sort)
arr = [12, 4, 54, 29, 46, 36, 72, 99, 85]



def bubble_for(data):
  n = len(data)
  for i in range(n - 1):
    for j in range (n - i - 1):
      if data[j] > data[j+1]:
        data[j],data[j+1] = data[j+1],data[j]
  return data

# Сортировка пузрьком через while (bubble sort)
def bubble_while(data):
  n = len(data)
  i = 0
  while i < n - 1:
    j = 0
    while j < n - 1 - i:
      if data[j] > data[j+1]:
        data[j],data[j+1] = data[j+1],data[j]
      j += 1
    i += 1
  return data



bubble_while(arr)

# Сортировка выбором
arr = [12, 4, 54, 29, 46, 36, 72, 99, 85]

def choice(data):
  n = len(data)
  i = 0
  while i < n - 1:
    m = i
    j = i + 1
    while j < n:
      if data[j] < data[m]:
        m = j
      j += 1
    data[i],data[m] = data[m],data[i]
    i += 1
  return data

choice(arr)

# Задача 2.1.

# Создайте две функции maximum и minimum,
# которые получают список целых чисел в качестве входных данных
# и возвращают наибольшее и наименьшее число в этом списке соответственно.
# Например,
# * [4,6,2,1,9,63,-134,566]         -> max = 566, min = -134
# * [-52, 56, 30, 29, -54, 0, -110] -> min = -110, max = 56
# * [42, 54, 65, 87, 0]             -> min = 0, max = 87
# * [5]                             -> min = 5, max = 5
# функции sorted, max и min использовать нельзя!
from datetime import datetime
arr = [[4,6,2,1,9,63,-134,566],[-52, 56, 30, 29, -54, 0, -110],[42, 54, 65, 87, 0],[5]]

def bubble_for(data):
  n = len(data)
  for i in range(n - 1):
    for j in range (n - i - 1):
      if data[j] > data[j+1]:
        data[j],data[j+1] = data[j+1],data[j]
  return data

def bubble_while(data):
  n = len(data)
  i = 0
  while i < n - 1:
    j = 0
    while j < n - 1 - i:
      if data[j] > data[j+1]:
        data[j],data[j+1] = data[j+1],data[j]
      j += 1
    i += 1
  return data

def choice(data):
  n = len(data)
  i = 0
  while i < n - 1:
    m = i
    j = i + 1
    while j < n:
      if data[j] < data[m]:
        m = j
      j += 1
    data[i],data[m] = data[m],data[i]
    i += 1
  return data



def minimum(arr):
    print ("МИНИМАЛЬНЫЕ ЗНАЧЕНИЯ")
    print ("Метод сортировки default")
    start_time = datetime.now()
    for data in arr:
      data = sorted(data)
      print ("Минимальное значение из массива:", data, min(data))
    end_time = datetime.now()
    print ("Прдолжительность: {}".format(end_time - start_time))

    print ("Метод сортировки bubble_for")
    start_time = datetime.now()
    for data in arr:
      print ("Минимальное значение из массива:", data, bubble_for(data)[0])
    end_time = datetime.now()
    print ("Прдолжительность: {}".format(end_time - start_time))

    print ("Метод сортировки bubble_while")
    start_time = datetime.now()
    for data in arr:
      print ("Минимальное значение из массива:", data, bubble_while(data)[0])
    end_time = datetime.now()
    print ("Прдолжительность: {}".format(end_time - start_time))

    print ("Метод сортировки choice")
    start_time = datetime.now()
    for data in arr:
      print ("Минимальное значение из массива:", data, choice(data)[0])
    end_time = datetime.now()
    print ("Прдолжительность: {}".format(end_time - start_time))



def maximum(arr):
    print ("МАКСИМАЛЬНЫЕ ЗНАЧЕНИЯ")
    print ("Метод сортировки default")
    start_time = datetime.now()
    for data in arr:
      data = sorted(data)
      print ("Максимальное значение из массива:", data, max(data))
    end_time = datetime.now()
    print ("Прдолжительность: {}".format(end_time - start_time))

    print ("Метод сортировки bubble_for")
    start_time = datetime.now()
    for data in arr:
      print ("Максимальное значение из массива:", data, bubble_for(data)[len(data)-1])
    end_time = datetime.now()
    print ("Прдолжительность: {}".format(end_time - start_time))

    print ("Метод сортировки bubble_while")
    start_time = datetime.now()
    for data in arr:
      print ("Максимальное значение из массива:", data, bubble_while(data)[len(data)-1])
    end_time = datetime.now()
    print ("Прдолжительность: {}".format(end_time - start_time))

    print ("Метод сортировки choice")
    start_time = datetime.now()
    for data in arr:
      print ("Максимальное значение из массива:", data, choice(data)[len(data)-1])
    end_time = datetime.now()
    print ("Прдолжительность: {}".format(end_time - start_time))


def main ():
  print (minimum(arr))
  print (maximum(arr))


print (main())

# Сортировка вставкой
arr = [12, 4, 54, 29, 46, 36, 72, 99, 85]

def insertion(data):
  for i in range(len(data)):
    j = i - 1
    key = data[i]
    while data[j] > key and j >= 0:
      data[j+1] = data[j]
      j -= 1
    data[j+1] = key
  return data

insertion(arr)

# Бинарный поиск обычный
import random

# Функция поиска
def binary_search(arr, x):
  low = 0
  high = len(arr) - 1
  index = -1
  while (low <= high) and (index == -1):
    mid = (low+high) // 2
    if arr[mid] == x:
      index = mid
    else:
      if x < arr[mid]:
        high = mid - 1
      else:
        low = mid + 1
  return index


# Тестовый массив
arr = []
for i in range(10):
  arr.append(random.randint(1,100))
arr.sort()
print (arr)
x = int(input("Введи число:"))

# Вызов функции
if binary_search(arr,x) != -1:
  print ('Элемент найден под индексом', binary_search(arr,x))
else:
  print ('Элемент не найден в массиве')

# Бинарный поиск через рекурсию
import random

def binar(arr, low, high, x):
  if high >= low:
    # Проверяем середину
    mid = (high + low) // 2
    # Если элемент в середине
    if arr[mid] == x:
      return mid
    # Если элемент в левой части
    elif arr[mid] > x:
      return binar(arr, low, mid - 1, x)
    # Если элемент в правой части
    else:
      return binar(arr,mid + 1, high,x)
  # Если элемент не в списке
  else:
    return -1




# Тестовый массив
arr = []
for i in range(10):
  arr.append(random.randint(1,100))
arr.sort()
print (arr)
x = int(input("Введи число:"))


# Вызов функции
result = binar(arr,0,len(arr)-1,x)

if result != -1:
  print ('Элемент найден под индексом', str(result))
else:
  print ('Элемент не найден в массиве')

# Jump Search
import random
import math

def jump_seacrh(arr,x):
  lenght = len(arr)
  jump = int(math.sqrt(lenght))
  left = 0
  right = 0
  while left < lenght and arr[left] <= x:
    right = min(lenght - 1, left + jump)
    if arr[left] <= x and arr[right] >= x:
      break
    left += jump
  if left >= lenght or arr[left] > x:
    return -1
  right = min(lenght - 1, right)
  i = left
  while i <= right and arr[i] <= x:
    if arr[i] == x:
      return i
    i += 1
  return -1

# Тестовый массив
arr = []
for i in range(10):
  arr.append(random.randint(1,100))
arr.sort()
print (arr)
x = int(input("Введи число:"))

# Вызов функции
if jump_seacrh(arr,x) != -1:
  print ('Элемент найден под индексом', jump_seacrh(arr,x))
else:
  print ('Элемент не найден в массиве')

# Экспоненциальный поиск
import random

def binary_search(arr, x):
  low = 0
  high = len(arr) - 1
  index = -1
  while (low <= high) and (index == -1):
    mid = (low+high) // 2
    if arr[mid] == x:
      index = mid
    else:
      if x < arr[mid]:
        high = mid - 1
      else:
        low = mid + 1
  return index

# Сама функция
def exp_search(arr,x):
  if arr[0] == x:
    return 0
  index = 1
  while index < len(arr) and arr[index] <= x:
    index = index * 2
  return binary_search(arr[:min(index,len(arr))], x)



# Тестовый массив
arr = []
for i in range(10):
  arr.append(random.randint(1,100))
arr.sort()
print (arr)
x = int(input("Введи число:"))

# Вызов функции
if jump_seacrh(arr,x) != -1:
  print ('Элемент найден под индексом', jump_seacrh(arr,x))
else:
  print ('Элемент не найден в массиве')